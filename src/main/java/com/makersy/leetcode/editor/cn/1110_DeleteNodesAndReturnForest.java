/**
 * ç»™å‡ºäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ rootï¼Œæ ‘ä¸Šæ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªä¸åŒçš„å€¼ã€‚
 * <p>
 * å¦‚æœèŠ‚ç‚¹å€¼åœ¨ to_delete ä¸­å‡ºç°ï¼Œæˆ‘ä»¬å°±æŠŠè¯¥èŠ‚ç‚¹ä»æ ‘ä¸Šåˆ å»ï¼Œæœ€åå¾—åˆ°ä¸€ä¸ªæ£®æ—ï¼ˆä¸€äº›ä¸ç›¸äº¤çš„æ ‘æ„æˆçš„é›†åˆï¼‰ã€‚
 * <p>
 * è¿”å›æ£®æ—ä¸­çš„æ¯æ£µæ ‘ã€‚ä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºç»„ç»‡ç­”æ¡ˆã€‚
 * <p>
 * <p>
 * <p>
 * ç¤ºä¾‹ 1ï¼š
 * <p>
 * <p>
 * <p>
 * <p>
 * è¾“å…¥ï¼šroot = [1,2,3,4,5,6,7], to_delete = [3,5]
 * è¾“å‡ºï¼š[[1,2,null,4],[6],[7]]
 * <p>
 * <p>
 * ç¤ºä¾‹ 2ï¼š
 * <p>
 * <p>
 * è¾“å…¥ï¼šroot = [1,2,4,null,3], to_delete = [3]
 * è¾“å‡ºï¼š[[1,2,4]]
 * <p>
 * <p>
 * <p>
 * <p>
 * æç¤ºï¼š
 * <p>
 * <p>
 * æ ‘ä¸­çš„èŠ‚ç‚¹æ•°æœ€å¤§ä¸º 1000ã€‚
 * æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªä»‹äº 1 åˆ° 1000 ä¹‹é—´çš„å€¼ï¼Œä¸”å„ä¸ç›¸åŒã€‚
 * to_delete.length <= 1000
 * to_delete åŒ…å«ä¸€äº›ä» 1 åˆ° 1000ã€å„ä¸ç›¸åŒçš„å€¼ã€‚
 * <p>
 * <p>
 * Related Topics æ ‘ æ·±åº¦ä¼˜å…ˆæœç´¢ æ•°ç»„ å“ˆå¸Œè¡¨ äºŒå‰æ ‘ ğŸ‘ 261 ğŸ‘ 0
 */

package com.makersy.leetcode.editor.cn;

import com.makersy.leetcode.editor.common.TreeNode;

import java.util.*;

class DeleteNodesAndReturnForest {
    public static void main(String[] args) {
        //Solution solution = new DeleteNodesAndReturnForest().new Solution();
    }

    //leetcode submit region begin(Prohibit modification and deletion)

    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     * int val;
     * TreeNode left;
     * TreeNode right;
     * TreeNode() {}
     * TreeNode(int val) { this.val = val; }
     * TreeNode(int val, TreeNode left, TreeNode right) {
     * this.val = val;
     * this.left = left;
     * this.right = right;
     * }
     * }
     */
    class Solution {
        List<TreeNode> roots;
        Set<Integer> dset;

        public List<TreeNode> delNodes(TreeNode root, int[] to_delete) {
            roots = new ArrayList<>();
            dset = new HashSet<>(to_delete.length);
            for (var n : to_delete) {
                dset.add(n);
            }
            dfs(root, true);
            return roots;
        }

        private TreeNode dfs(TreeNode node, boolean isRoot) {
            if (node == null) return null;
            boolean flag = dset.contains(node.val);
            node.left = dfs(node.left, flag);
            node.right = dfs(node.right, flag);

            if (flag) {
                return null;
            }
            if (isRoot) {
                roots.add(node);
                return null;
            }
            return node;
        }
    }
//leetcode submit region end(Prohibit modification and deletion)

}